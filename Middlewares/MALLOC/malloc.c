#include "malloc.h"

//内存池(64Byte对齐)

__align(64) u8 mem1base[MEM1_MAX_SIZE];                                  // (448KB/512KB) 内部SRAM内存池
__align(64) u8 mem2base[MEM2_MAX_SIZE] __attribute__((at(0XC01F4000)));  // ( 62MB/ 64MB) 外部SDRAM内存池,前面2M固定分配给LTDC使用(0xC0100000 ~ 0XC01F4000)
__align(64) u8 mem3base[MEM3_MAX_SIZE] __attribute__((at(0x30000000)));  // (240KB/256KB) 内部SRAM1+SRAM2内存池
__align(64) u8 mem4base[MEM4_MAX_SIZE] __attribute__((at(0x38000000)));  // ( 60KB/ 64KB) 内部SRAM4内存池
__align(64) u8 mem5base[MEM5_MAX_SIZE] __attribute__((at(0x20000000)));  // (120KB/128KB) 内部DTCM内存池
__align(64) u8 mem6base[MEM6_MAX_SIZE] __attribute__((at(0x00000000)));  // ( 60KB/ 64KB) 内部ITCM内存池 

//内存管理表

u32 mem1mapbase[MEM1_ALLOC_TABLE_SIZE];                                                  //内部SRAM内存池MAP
u32 mem2mapbase[MEM2_ALLOC_TABLE_SIZE] __attribute__((at(0XC01F4000 + MEM2_MAX_SIZE)));  //外部SDRAM内存池MAP
u32 mem3mapbase[MEM3_ALLOC_TABLE_SIZE] __attribute__((at(0x30000000 + MEM3_MAX_SIZE)));  //内部SRAM1+SRAM2内存池MAP
u32 mem4mapbase[MEM4_ALLOC_TABLE_SIZE] __attribute__((at(0x38000000 + MEM4_MAX_SIZE)));  //内部SRAM4内存池MAP
u32 mem5mapbase[MEM5_ALLOC_TABLE_SIZE] __attribute__((at(0x20000000 + MEM5_MAX_SIZE)));  //内部DTCM内存池MAP
u32 mem6mapbase[MEM6_ALLOC_TABLE_SIZE] __attribute__((at(0x00000000 + MEM6_MAX_SIZE)));  //内部ITCM内存池MAP

//内存管理参数

const u32 memtblsize[SRAMBANK] = {MEM1_ALLOC_TABLE_SIZE, MEM2_ALLOC_TABLE_SIZE, MEM3_ALLOC_TABLE_SIZE,  //内存表大小
                                  MEM4_ALLOC_TABLE_SIZE, MEM5_ALLOC_TABLE_SIZE, MEM6_ALLOC_TABLE_SIZE};
const u32 memblksize[SRAMBANK] = {MEM1_BLOCK_SIZE, MEM2_BLOCK_SIZE, MEM3_BLOCK_SIZE,                    //内存分块大小
                                  MEM4_BLOCK_SIZE, MEM5_BLOCK_SIZE, MEM6_BLOCK_SIZE};
const u32 memsize[SRAMBANK]    = {MEM1_MAX_SIZE, MEM2_MAX_SIZE, MEM3_MAX_SIZE,                          //内存总大小
                                  MEM4_MAX_SIZE, MEM5_MAX_SIZE, MEM6_MAX_SIZE};

//内存管理控制器
struct _m_mallco_dev mallco_dev=
{
    my_mem_init,     //内存初始化
    my_mem_perused,  //内存使用率
    mem1base,    mem2base,    mem3base,    mem4base,    mem5base,    mem6base,     //内存池
    mem1mapbase, mem2mapbase, mem3mapbase, mem4mapbase, mem5mapbase, mem6mapbase,  //内存管理状态表
    0,           0,           0,           0,           0,           0,            //内存管理默认未就绪
};

/**
 * @brief 复制内存
 * 
 * @param des 目的地址
 * @param src 源地址
 * @param n   需要复制的内存长度(Byte)
 */
void mymemcpy(void *des, void *src, u32 n)
{
    u8 *xdes = des;
    u8 *xsrc = src;
    while(n--)
        *xdes++ = *xsrc++;
}

/**
 * @brief 设置内存
 * 
 * @param s     内存首地址
 * @param c     要设置的值
 * @param count 需要设置的内存大小(Byte)
 */
void mymemset(void *s, u8 c, u32 count)
{
    u8 *xs = s;
    while(count--)
        *xs++ = c;
}

/**
 * @brief 内存管理初始化
 * 
 * @param memx 所属内存块
 */
void my_mem_init(u8 memx)
{
    mymemset(mallco_dev.memmap[memx], 0, memtblsize[memx]*4);  //内存状态表数据清零
    mallco_dev.memrdy[memx] = 1;                               //内存管理就绪
}

/**
 * @brief 初始化北极星开发板全部内存管理
 * 
 */
void my_mem_init_all(void)
{
    my_mem_init(SRAMIN);    //初始化内部内存池(AXI)
    my_mem_init(SRAMEX);    //初始化外部内存池(SDRAM)
    my_mem_init(SRAM12);    //初始化SRAM12内存池(SRAM1+SRAM2)
    my_mem_init(SRAM4);     //初始化SRAM4内存池(SRAM4)
    my_mem_init(SRAMDTCM);  //初始化DTCM内存池(DTCM)
    my_mem_init(SRAMITCM);  //初始化ITCM内存池(ITCM)
}

/**
 * @brief 获取内存使用率
 * 
 * @param memx 所属内存块
 * @return u16 使用率(扩大了10倍,0~1000,代表0.0%~100.0%)
 */
u16 my_mem_perused(u8 memx)
{
    u32 used = 0;
    u32 i;
    for(i=0; i<memtblsize[memx]; i++)
    {
        if(mallco_dev.memmap[memx][i])
            used++;
    }
    return (used*1000)/(memtblsize[memx]);
}

/**
 * @brief 内存分配(内部调用)
 * 
 * @param memx 所属内存块
 * @param size 要分配的内存大小(Byte)
 * @return u32 0XFFFFFFFF:错误 其他:内存偏移地址
 */
u32 my_mem_malloc(u8 memx, u32 size)
{  
    signed long offset=0;
    u32 nmemb;      //需要的内存块数
    u32 cmemb = 0;  //连续空内存块数
    u32 i;
    if(!mallco_dev.memrdy[memx])    //未初始化,先执行初始化
        mallco_dev.init(memx);
    if(size == 0)                   //不需要分配
        return 0XFFFFFFFF;
    nmemb = size/memblksize[memx];  //获取需要分配的连续内存块数
    if(size%memblksize[memx])
        nmemb++;
    for(offset=memtblsize[memx]-1; offset>=0; offset--)  //搜索整个内存控制区
    {
        if(!mallco_dev.memmap[memx][offset])   //连续空内存块数增加
            cmemb++;
        else                                   //连续内存块清零
            cmemb=0;
        if(cmemb == nmemb)                     //找到了连续nmemb个空内存块
        {
            for(i=0;i<nmemb;i++)               //标注内存块非空
                mallco_dev.memmap[memx][offset+i] = nmemb;
            return (offset*memblksize[memx]);  //返回偏移地址
        }
    }
    return 0XFFFFFFFF;  //未找到符合分配条件的内存块
}

/**
 * @brief 释放内存(内部调用)
 * 
 * @param memx   所属内存块
 * @param offset 内存地址偏移
 * @return u8 0:释放成功 1:释放失败 2:偏移超区
 */
u8 my_mem_free(u8 memx, u32 offset)  
{
    int i;
    if(!mallco_dev.memrdy[memx])  //未初始化,先执行初始化
    {
        mallco_dev.init(memx);
        return 1;  //未初始化
    }
    if(offset<memsize[memx])      //偏移在内存池内
    {
        int index = offset/memblksize[memx];         //偏移所在内存块号码
        int nmemb = mallco_dev.memmap[memx][index];  //内存块数量
        for(i=0; i<nmemb; i++)                       //内存块清零
            mallco_dev.memmap[memx][index+i] = 0;
        return 0;
    }
    else
        return 2;  //偏移超区
}

/**
 * @brief 释放内存(外部调用)
 * 
 * @param memx 所属内存块
 * @param ptr  内存首地址
 */
void myfree(u8 memx, void *ptr)  
{  
    u32 offset;
    if(ptr==NULL)  //地址为0
        return;
    offset = (u32)ptr - (u32)mallco_dev.membase[memx];
    my_mem_free(memx,offset);  //释放内存
}

/**
 * @brief 分配内存(外部调用)
 * 
 * @param memx 所属内存块
 * @param size 内存大小(Byte)
 * @return void* 分配到的内存首地址
 */
void *mymalloc(u8 memx, u32 size)
{
    u32 offset;
    offset = my_mem_malloc(memx, size);
    if(offset == 0XFFFFFFFF)
        return NULL;
    else
        return (void*)((u32)mallco_dev.membase[memx]+offset);
}

/**
 * @brief 重新分配内存(外部调用)
 * 
 * @param memx 所属内存块
 * @param ptr  旧内存首地址
 * @param size 要分配的内存大小(Byte)
 * @return void* 新分配到的内存首地址
 */
void *myrealloc(u8 memx, void *ptr, u32 size)  
{  
    u32 offset;
    offset = my_mem_malloc(memx, size);
    if(offset == 0XFFFFFFFF)
        return NULL;
    else
    {
        mymemcpy((void*)((u32)mallco_dev.membase[memx]+offset), ptr, size);  //拷贝旧内存内容到新内存
        myfree(memx, ptr);                                                   //释放旧内存
        return (void*)((u32)mallco_dev.membase[memx]+offset);                //返回新内存首地址
    }
}
