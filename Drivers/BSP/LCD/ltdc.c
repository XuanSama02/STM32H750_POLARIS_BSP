#include "ltdc.h"
#include "lcd.h"

LTDC_HandleTypeDef  LTDC_Handler;   //LTDC句柄
DMA2D_HandleTypeDef DMA2D_Handler;  //DMA2D句柄

//根据不同的颜色格式,定义帧缓存数组

#if LCD_PIXFORMAT==LCD_PIXFORMAT_ARGB8888 || LCD_PIXFORMAT==LCD_PIXFORMAT_RGB888
    u32 ltdc_lcd_framebuf[1280][800] __attribute__((at(LCD_FRAME_BUF_ADDR)));  //定义最大屏分辨率时,LCD所需的帧缓存数组大小
#else
    u16 ltdc_lcd_framebuf[1280][800] __attribute__((at(LCD_FRAME_BUF_ADDR)));  //定义最大屏分辨率时,LCD所需的帧缓存数组大小
#endif

u32 *ltdc_framebuf[2];  //LTDC LCD帧缓存数组指针,必须指向对应大小的内存区域
_ltdc_dev lcdltdc;      //管理LCD LTDC的重要参数

/**
 * @brief 初始化LTDC
 * 
 */
void ltdc_init(void)
{   
    u16 lcd_id = 0;
    lcd_id = ltdc_panel_id();  //读取LCD面板ID
    //根据读取到的LCD进行LTDC参数配置
    if(lcd_id == 0X4384)  //4.3寸800*480 RGB屏
    {
        lcdltdc.pwidth  = 800;  //面板宽度,单位:像素
        lcdltdc.pheight = 480;  //面板高度,单位:像素
        lcdltdc.hbp     = 88;   //水平后廊
        lcdltdc.hfp     = 40;   //水平前廊
        lcdltdc.hsw     = 48;   //水平同步宽度
        lcdltdc.vbp     = 32;   //垂直后廊
        lcdltdc.vfp     = 13;   //垂直前廊
        lcdltdc.vsw     = 3;    //垂直同步宽度
        ltdc_clk_config(5, 160, 24);  //设置像素时钟 33M
        //其他参数待定
    }
    #if(LCD_70_1024_600_ENABLE == 1)
    else if(lcd_id == 0X7016)  //7寸1024*600 RGB屏
    {
        lcdltdc.pwidth  = 1024;  //面板宽度,单位:像素
        lcdltdc.pheight = 600;   //面板高度,单位:像素
        lcdltdc.hsw     = 20;    //水平同步宽度
        lcdltdc.vsw     = 3;     //垂直同步宽度
        lcdltdc.hbp     = 140;   //水平后廊
        lcdltdc.vbp     = 20;    //垂直后廊
        lcdltdc.hfp     = 160;   //水平前廊
        lcdltdc.vfp     = 12;    //垂直前廊
        ltdc_clk_config(5, 160, 18);  //设置像素时钟 45Mhz
        //其他参数待定
    }
    #endif
    #if(LCD_43_480_272_ENABLE == 1)
    else if(lcd_id == 0X4342)  //4.3寸480*272 RGB屏
    {
        lcdltdc.pwidth  = 480;  //面板宽度,单位:像素
        lcdltdc.pheight = 272;  //面板高度,单位:像素
        lcdltdc.hsw     = 1;    //水平同步宽度
        lcdltdc.vsw     = 1;    //垂直同步宽度
        lcdltdc.hbp     = 40;   //水平后廊
        lcdltdc.vbp     = 8;    //垂直后廊
        lcdltdc.hfp     = 5;    //水平前廊
        lcdltdc.vfp     = 8;    //垂直前廊
        ltdc_clk_config(5, 160, 88);  //设置像素时钟:9Mhz
        //其他参数待定
    }
    #endif
    #if(LCD_70_800_480_ENABLE == 1)
    else if(lcd_id == 0X7084)  //7寸800*480 RGB屏
    {
        lcdltdc.pwidth  = 800;  //面板宽度,单位:像素
        lcdltdc.pheight = 480;  //面板高度,单位:像素
        lcdltdc.hsw     = 1;    //水平同步宽度
        lcdltdc.vsw     = 1;    //垂直同步宽度
        lcdltdc.hbp     = 46;   //水平后廊
        lcdltdc.vbp     = 23;   //垂直后廊
        lcdltdc.hfp     = 210;  //水平前廊
        lcdltdc.vfp     = 22;   //垂直前廊
        ltdc_clk_config(5, 160, 24);  //设置像素时钟 33M(如果开双显,需要降低DCLK到:18.75Mhz, pll3r=43,比较好)
    }
    #endif
    #if(LCD_101_1280_800_ENABLE == 1)
    else if(lcd_id == 0X1018)  //10.1寸1280*800 RGB屏
    {
        lcdltdc.pwidth  = 1280;  //面板宽度,单位:像素
        lcdltdc.pheight = 800;   //面板高度,单位:像素
        lcdltdc.hbp     = 140;   //水平后廊
        lcdltdc.hfp     = 10;    //水平前廊
        lcdltdc.hsw     = 10;    //水平同步宽度
        lcdltdc.vbp     = 10;    //垂直后廊
        lcdltdc.vfp     = 10;    //垂直前廊
        lcdltdc.vsw     = 3;     //垂直同步宽度
        ltdc_clk_config(5, 160, 16);  //设置像素时钟 50MHz
    }
    #endif
    #if(LCD_VGA_ENBALE == 1)
    else if(lcd_id == 0XA001)  //接VGA显示器: 1366*768
    {
        lcdltdc.pwidth  = 1366;  //面板宽 度,单位:像素
        lcdltdc.pheight = 768;   //面板高度,单位:像素
        lcdltdc.hsw     = 143;   //水平同步宽度 
        lcdltdc.hfp     = 70;    //水平前廊
        lcdltdc.hbp     = 213;   //水平后廊
        lcdltdc.vsw     = 3;     //垂直同步宽度
        lcdltdc.vbp     = 24;    //垂直后廊
        lcdltdc.vfp     = 3;     //垂直前廊
        ltdc_clk_config(5, 160, 28);  //设置像素时钟 28.5Mhz
    }
    else if(lcd_id == 0XA002)  //接VGA显示器: 1280*800
    {
        lcdltdc.pwidth  = 1280;  //面板宽度,单位:像素
        lcdltdc.pheight = 800;   //面板高度,单位:像素
        lcdltdc.hsw     = 32;    //水平同步宽度
        lcdltdc.hfp     = 48;    //水平前廊
        lcdltdc.hbp     = 80;    //水平后廊
        lcdltdc.vsw     = 6;     //垂直同步宽度
        lcdltdc.vbp     = 14;    //垂直后廊
        lcdltdc.vfp     = 3;     //垂直前廊
        ltdc_clk_config(5, 160, 22);  //设置像素时钟 35.5Mhz
    }
    else if(lcd_id == 0XA003)  //接VGA显示器: 1280*768
    {
        lcdltdc.pwidth  = 1280;  //面板宽度,单位:像素
        lcdltdc.pheight = 768;   //面板高度,单位:像素
        lcdltdc.hsw     = 32;    //水平同步宽度 
        lcdltdc.hbp     = 80;    //水平后廊
        lcdltdc.hfp     = 48;    //水平前廊
        lcdltdc.vsw     = 7;     //垂直同步宽度
        lcdltdc.vbp     = 12;    //垂直后廊
        lcdltdc.vfp     = 3;     //垂直前廊
        ltdc_clk_config(5, 160, 23);  //设置像素时钟  34.25Mhz
    }
    else if(lcd_id == 0XA004)  //接VGA显示器: 1024*768
    {
        lcdltdc.pwidth  = 1024;  //面板宽度,单位:像素
        lcdltdc.pheight = 768;   //面板高度,单位:像素
        lcdltdc.hsw     = 136;   //水平同步宽度 
        lcdltdc.hfp     = 24;    //水平前廊
        lcdltdc.hbp     = 160;   //水平后廊
        lcdltdc.vsw     = 6;     //垂直同步宽度
        lcdltdc.vbp     = 29;    //垂直后廊
        lcdltdc.vfp     = 3;     //垂直前廊
        ltdc_clk_config(5, 160, 18);  //设置像素时钟 43.25Mhz
    }
    else if(lcd_id == 0XA005)  //接VGA显示器: 848*480
    {
        lcdltdc.pwidth  = 848;  //面板宽度,单位:像素
        lcdltdc.pheight = 480;  //面板高度,单位:像素
        lcdltdc.hsw     = 112;  //水平同步宽度
        lcdltdc.hbp     = 112;  //水平后廊
        lcdltdc.hfp     = 16;   //水平前廊
        lcdltdc.vsw     = 8;    //垂直同步宽度
        lcdltdc.vbp     = 23;   //垂直后廊
        lcdltdc.vfp     = 6;    //垂直前廊
        ltdc_clk_config(5, 160, 47);//设置像素时钟 17Mhz
    }
    else if(lcd_id == 0XA006)  //接VGA显示器: 800*600
    {
        lcdltdc.pwidth  = 800;  //面板宽度,单位:像素
        lcdltdc.pheight = 600;  //面板高度,单位:像素
        lcdltdc.hsw     = 128;  //水平同步宽度
        lcdltdc.hbp     = 88;   //水平后廊
        lcdltdc.hfp     = 40;   //水平前廊
        lcdltdc.vsw     = 4;    //垂直同步宽度
        lcdltdc.vbp     = 23;   //垂直后廊
        lcdltdc.vfp     = 1;    //垂直前廊
        ltdc_clk_config(5, 160, 40);  //设置像素时钟 20mz
    }
    else if(lcd_id == 0XA007)  //接VGA显示器: 640*480
    {
        lcdltdc.pwidth  = 640;  //面板宽度,单位:像素
        lcdltdc.pheight = 480;  //面板高度,单位:像素
        lcdltdc.hsw     = 96;   //水平同步宽度
        lcdltdc.hfp     = 8;    //水平前廊
        lcdltdc.hbp     = 56;   //水平后廊
        lcdltdc.vsw     = 2;    //垂直同步宽度
        lcdltdc.vbp     = 41;   //垂直后廊
        lcdltdc.vfp     = 2;    //垂直前廊
        ltdc_clk_config(5, 160, 62);  //设置像素时钟 12.75Mhz
    }
    #endif
    //确认显示的长宽像素
    lcddev.width  = lcdltdc.pwidth;
    lcddev.height = lcdltdc.pheight;

#if LCD_PIXFORMAT==LCD_PIXFORMAT_ARGB8888 || LCD_PIXFORMAT==LCD_PIXFORMAT_RGB888
    ltdc_framebuf[0] = (u32*)&ltdc_lcd_framebuf;
    lcdltdc.pixsize  = 4;  //每个像素占4个字节
#else
    ltdc_framebuf[0] = (u32*)&ltdc_lcd_framebuf;
    lcdltdc.pixsize  = 2;  //每个像素占2个字节
#endif

    //LTDC配置
    LTDC_Handler.Instance = LTDC;
    LTDC_Handler.Init.HSPolarity = LTDC_HSPOLARITY_AL;   //水平同步极性
    LTDC_Handler.Init.VSPolarity = LTDC_VSPOLARITY_AL;   //垂直同步极性
    LTDC_Handler.Init.DEPolarity = LTDC_DEPOLARITY_AL;   //数据使能极性
    LTDC_Handler.Init.PCPolarity = LTDC_PCPOLARITY_IPC;  //像素时钟极性
    if(lcd_id == 0X1018)  //10.1寸RGB屏,像素时钟极性相反
        LTDC_Handler.Init.PCPolarity = LTDC_PCPOLARITY_IIPC;
    LTDC_Handler.Init.HorizontalSync     = lcdltdc.hsw -1;  //水平同步宽度
    LTDC_Handler.Init.VerticalSync       = lcdltdc.vsw -1;  //垂直同步宽度
    LTDC_Handler.Init.AccumulatedHBP     = lcdltdc.hsw + lcdltdc.hbp -1;  //水平同步后沿宽度
    LTDC_Handler.Init.AccumulatedVBP     = lcdltdc.vsw + lcdltdc.vbp -1;  //垂直同步后沿高度
    LTDC_Handler.Init.AccumulatedActiveW = lcdltdc.hsw + lcdltdc.hbp + lcdltdc.pwidth  -1;  //有效宽度
    LTDC_Handler.Init.AccumulatedActiveH = lcdltdc.vsw + lcdltdc.vbp + lcdltdc.pheight -1;  //有效高度
    LTDC_Handler.Init.TotalWidth         = lcdltdc.hsw + lcdltdc.hbp + lcdltdc.pwidth  + lcdltdc.hfp -1;  //总宽度
    LTDC_Handler.Init.TotalHeigh         = lcdltdc.vsw + lcdltdc.vbp + lcdltdc.pheight + lcdltdc.vfp -1;  //总高度
    LTDC_Handler.Init.Backcolor.Red      = 0;  //屏幕背景层红色部分
    LTDC_Handler.Init.Backcolor.Green    = 0;  //屏幕背景层绿色部分
    LTDC_Handler.Init.Backcolor.Blue     = 0;  //屏幕背景色蓝色部分
    HAL_LTDC_Init(&LTDC_Handler);
    //layer配置
    ltdc_layer_parameter_config(0, (u32)ltdc_framebuf[0], LCD_PIXFORMAT, 255, 0, 6, 7, 0X000000);  //层参数配置
    ltdc_layer_window_config(0, 0, 0, lcdltdc.pwidth, lcdltdc.pheight);  //层窗口配置,以LCD面板坐标系为基准
    //LTDC初始设置
    ltdc_display_direction(0);  //默认竖屏，在LCD_Init函数里面设置
    ltdc_layer_select(0);       //选择第1层
    LCD_LED(1);                 //点亮背光
    ltdc_clear(0XFFFFFFFF);     //清屏
}

/**
 * @brief LTDC底层驱动,初始化IO,时钟使能
 * 
 * @param hltdc LTDC句柄
 */
void HAL_LTDC_MspInit(LTDC_HandleTypeDef* hltdc)
{
    GPIO_InitTypeDef ymx_gpio_init;
    //使能时钟
    __HAL_RCC_LTDC_CLK_ENABLE();   //使能LTDC时钟
    __HAL_RCC_DMA2D_CLK_ENABLE();  //使能DMA2D时钟
    __HAL_RCC_GPIOB_CLK_ENABLE();  //使能GPIOB时钟
    __HAL_RCC_GPIOI_CLK_ENABLE();  //使能GPIOI时钟
    __HAL_RCC_GPIOJ_CLK_ENABLE();  //使能GPIOJ时钟
    __HAL_RCC_GPIOK_CLK_ENABLE();  //使能GPIOK时钟
    //初始化PB5，背光引脚
    ymx_gpio_init.Pin   = GPIO_PIN_5;                 //PB5背光引脚
    ymx_gpio_init.Mode  = GPIO_MODE_OUTPUT_PP;        //推挽输出
    ymx_gpio_init.Pull  = GPIO_PULLUP;                //上拉
    ymx_gpio_init.Speed = GPIO_SPEED_FREQ_VERY_HIGH;  //高速
    HAL_GPIO_Init(GPIOB, &ymx_gpio_init);
    //初始化PI12,13,14
    ymx_gpio_init.Pin       = GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14;
    ymx_gpio_init.Mode      = GPIO_MODE_AF_PP;            //复用推挽
    ymx_gpio_init.Pull      = GPIO_NOPULL;                //不上拉下拉
    ymx_gpio_init.Speed     = GPIO_SPEED_FREQ_VERY_HIGH;  //高速
    ymx_gpio_init.Alternate = GPIO_AF14_LTDC;             //复用为LTDC
    HAL_GPIO_Init(GPIOI, &ymx_gpio_init);
    //初始化PJ2~6,9~11,15
    ymx_gpio_init.Pin=GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_4|GPIO_PIN_5|\
                      GPIO_PIN_6|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11|\
                      GPIO_PIN_15;
    HAL_GPIO_Init(GPIOJ, &ymx_gpio_init);
    //初始化PK0~7
    ymx_gpio_init.Pin=GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_4|\
                      GPIO_PIN_5|GPIO_PIN_6|GPIO_PIN_7;
    HAL_GPIO_Init(GPIOK, &ymx_gpio_init);
}

/**
 * @brief 读取LCD面板参数
 *        PJ6=R7(M0) PK2=G7(M1) PK6=B7(M2)
 *        M2:M1:M0
 *        0 :0 :0  //4.3寸480*272 RGB屏,ID=0X4342
 *        0 :0 :1  //7寸800*480 RGB屏,ID=0X7084
 *        0 :1 :0  //7寸1024*600 RGB屏,ID=0X7016
 *        0 :1 :1  //7寸1280*800 RGB屏,ID=0X7018
 *        1 :0 :0  //4.3寸800*480 RGB屏,ID=0X4384
 *        1 :0 :1  //10.1寸1280*800 RGB屏,ID=0X1018
 * 
 * @return u16 LCD的ID, 0:非法
 */
u16 ltdc_panel_id(void)
{
    u8 lcd_id = 0;
    GPIO_InitTypeDef ymx_gpio_init;
    //使能时钟
    __HAL_RCC_GPIOJ_CLK_ENABLE();  //使能GPIOJ时钟
    __HAL_RCC_GPIOK_CLK_ENABLE();  //使能GPIOK时钟
    //配置GPIO
    ymx_gpio_init.Pin   = GPIO_PIN_6;                 //PJ6
    ymx_gpio_init.Mode  = GPIO_MODE_INPUT;            //输入
    ymx_gpio_init.Speed = GPIO_SPEED_FREQ_VERY_HIGH;  //高速
    HAL_GPIO_Init(GPIOJ, &ymx_gpio_init);

    ymx_gpio_init.Pin   = GPIO_PIN_2|GPIO_PIN_6;  //PK2,6
    HAL_GPIO_Init(GPIOK, &ymx_gpio_init);
    //读取LCD的ID
    lcd_id  = (u8)HAL_GPIO_ReadPin(GPIOJ, GPIO_PIN_6);     //读取M0
    lcd_id |= (u8)HAL_GPIO_ReadPin(GPIOK, GPIO_PIN_2)<<1;  //读取M1
    lcd_id |= (u8)HAL_GPIO_ReadPin(GPIOK, GPIO_PIN_6)<<2;  //读取M2
    if(lcd_id == 0)       //4.3寸屏,480*272分辨率
        return 0X4342;
    else if(lcd_id == 1)  //7寸屏,800*480分辨率
        return 0X7084;
    else if(lcd_id == 2)  //7寸屏,1024*600分辨率
        return 0X7016;
    else if(lcd_id == 3)  //7寸屏,1280*800分辨率(已绝版)
        return 0X7018;
    else if(lcd_id == 4)  //4.3寸屏,800*480分辨率
        return 0X4384;
    else if(lcd_id == 5)  //10.1寸屏,1280*800分辨率
        return 0X1018;
    else
        return 0;
}

/**
 * @brief LTDC时钟设置
 *        PLL3_VCO_in  = HSE/PLL3M
 *        PLL3_VCO_out = PLL3_VCO_in*PLL3N
 *        PLL_LCD_CLK  = PLL3_VCO_out/PLL3R
 * 
 * @param pll3m PLL3M(分频)
 * @param pll3n PLL3N(倍频)
 * @param pll3r PLL3R(分频)
 * @return u8 1:失败 0:成功
 */
u8 ltdc_clk_config(u32 pll3m, u32 pll3n, u32 pll3r)
{
    RCC_PeriphCLKInitTypeDef ymx_periph_clk_init;
    ymx_periph_clk_init.PeriphClockSelection = RCC_PERIPHCLK_LTDC;
    ymx_periph_clk_init.PLL3.PLL3M = pll3m;
    ymx_periph_clk_init.PLL3.PLL3N = pll3n;
    ymx_periph_clk_init.PLL3.PLL3P = 2;
    ymx_periph_clk_init.PLL3.PLL3Q = 2;
    ymx_periph_clk_init.PLL3.PLL3R = pll3r;
    if(HAL_RCCEx_PeriphCLKConfig(&ymx_periph_clk_init) == HAL_OK)  //配置像素时钟，这里配置为时钟为18.75MHZ
        return 0;  //成功
    else
        return 1;  //失败
}

/**
 * @brief LTDC使能开关
 * 
 * @param sw 1:开启 0:关闭
 */
void ltdc_switch(u8 sw)
{
    if(sw == 1)
        __HAL_LTDC_ENABLE(&LTDC_Handler);
    else if(sw == 0)
        __HAL_LTDC_DISABLE(&LTDC_Handler);
}

/**
 * @brief LTDC指定layer开关
 * 
 * @param layerx layer编号,默认0
 * @param sw     1:打开 0:关闭
 */
void ltdc_layer_switch(u8 layerx, u8 sw)
{
    if(sw == 1)
        __HAL_LTDC_LAYER_ENABLE(&LTDC_Handler, layerx);
    else if(sw == 0)
        __HAL_LTDC_LAYER_DISABLE(&LTDC_Handler, layerx);
    __HAL_LTDC_RELOAD_CONFIG(&LTDC_Handler);
}

/**
 * @brief 选中layer
 * 
 * @param layerx 层编号,默认0
 */
void ltdc_layer_select(u8 layerx)
{
    lcdltdc.activelayer = layerx;
}

/**
 * @brief LTDC基本参数设置,此函数必须在ltdc_layer_window_config之前设置
 * 
 * @param layerx    层编号,默认0
 * @param bufaddr   层颜色帧缓存起始地址
 * @param pixformat 颜色格式 0:ARGB8888 1:RGB888 2:RGB565 3:ARGB1555 4:ARGB4444 5:L8 6:AL44 7:AL88
 * @param alpha     层颜色Alpha值 0:全透明 255:不透明
 * @param alpha0    默认颜色Alpha值 0:全透明 255:不透明
 * @param bfac1     混合系数1 4(100),恒定的Alpha 6(101),像素Alpha*恒定Alpha
 * @param bfac2     混合系数2 5(101),恒定的Alpha 7(111),像素Alpha*恒定Alpha
 * @param bkcolor   层默认颜色 32位,低24位有效,RGB888格式
 */
void ltdc_layer_parameter_config(u8 layerx, u32 bufaddr, u8 pixformat, u8 alpha, u8 alpha0, u8 bfac1, u8 bfac2, u32 bkcolor)
{
    LTDC_LayerCfgTypeDef ymx_layer_config;
    //配置layer
    ymx_layer_config.WindowX0        = 0;                             //窗口起始X坐标
    ymx_layer_config.WindowY0        = 0;                             //窗口起始Y坐标
    ymx_layer_config.WindowX1        = lcdltdc.pwidth;                //窗口终止X坐标
    ymx_layer_config.WindowY1        = lcdltdc.pheight;               //窗口终止Y坐标
    ymx_layer_config.PixelFormat     = pixformat;                     //像素格式
    ymx_layer_config.Alpha           = alpha;                         //Alpha值设置，0~255,255为完全不透明
    ymx_layer_config.Alpha0          = alpha0;                        //默认Alpha值
    ymx_layer_config.BlendingFactor1 = (u32)bfac1<<8;                 //设置层混合系数
    ymx_layer_config.BlendingFactor2 = (u32)bfac2<<8;                 //设置层混合系数
    ymx_layer_config.FBStartAdress   = bufaddr;                       //设置层颜色帧缓存起始地址
    ymx_layer_config.ImageWidth      = lcdltdc.pwidth;                //设置颜色帧缓冲区的宽度
    ymx_layer_config.ImageHeight     = lcdltdc.pheight;               //设置颜色帧缓冲区的高度
    ymx_layer_config.Backcolor.Red   = (u8)(bkcolor&0X00FF0000)>>16;  //背景颜色红色部分
    ymx_layer_config.Backcolor.Green = (u8)(bkcolor&0X0000FF00)>>8;   //背景颜色绿色部分
    ymx_layer_config.Backcolor.Blue  = (u8)bkcolor&0X000000FF;        //背景颜色蓝色部分
    HAL_LTDC_ConfigLayer(&LTDC_Handler, &ymx_layer_config,layerx);    //设置所选中的层
}

/**
 * @brief LTDC层窗口设置,以LCD面板坐标系为基准,此函数必须在ltdc_layer_parameter_config之后再设置
 * 
 * @param layerx 层编号,默认0
 * @param sx     起始水平坐标
 * @param sy     起始垂直坐标
 * @param width  显示宽度
 * @param height 显示高度
 */
void ltdc_layer_window_config(u8 layerx, u16 sx, u16 sy, u16 width, u16 height)
{
    HAL_LTDC_SetWindowPosition(&LTDC_Handler, sx, sy, layerx);     //设置窗口的位置
    HAL_LTDC_SetWindowSize(&LTDC_Handler, width, height, layerx);  //设置窗口大小
}

/**
 * @brief 设置LTDC显示方向
 * 
 * @param dir 0:竖屏 1:横屏
 */
void ltdc_display_direction(u8 dir)
{
    lcdltdc.dir = dir;  //显示方向
    if(dir == 0)        //竖屏
    {
        lcdltdc.width  = lcdltdc.pheight;
        lcdltdc.height = lcdltdc.pwidth;
    }else if(dir == 1)  //横屏
    {
        lcdltdc.width  = lcdltdc.pwidth;
        lcdltdc.height = lcdltdc.pheight;
    }
}

/**
 * @brief 画点函数
 * 
 * @param x     水平坐标
 * @param y     垂直桌标
 * @param color 颜色值
 */
void ltdc_draw_point(u16 x, u16 y, u32 color)
{ 
#if LCD_PIXFORMAT==LCD_PIXFORMAT_ARGB8888 || LCD_PIXFORMAT==LCD_PIXFORMAT_RGB888
    if(lcdltdc.dir)  //横屏
        *(u32*)((u32)ltdc_framebuf[lcdltdc.activelayer]+lcdltdc.pixsize*(lcdltdc.pwidth*y+x)) = color;
    else             //竖屏
        *(u32*)((u32)ltdc_framebuf[lcdltdc.activelayer]+lcdltdc.pixsize*(lcdltdc.pwidth*(lcdltdc.pheight-x-1)+y)) = color;
#else
    if(lcdltdc.dir)  //横屏
        *(u16*)((u32)ltdc_framebuf[lcdltdc.activelayer]+lcdltdc.pixsize*(lcdltdc.pwidth*y+x)) = color;
    else             //竖屏
        *(u16*)((u32)ltdc_framebuf[lcdltdc.activelayer]+lcdltdc.pixsize*(lcdltdc.pwidth*(lcdltdc.pheight-x-1)+y)) = color; 
#endif
}

/**
 * @brief 读点函数
 * 
 * @param x 水平坐标
 * @param y 垂直坐标
 * @return u32 颜色值
 */
u32 ltdc_read_point(u16 x, u16 y)
{ 
#if LCD_PIXFORMAT==LCD_PIXFORMAT_ARGB8888 || LCD_PIXFORMAT==LCD_PIXFORMAT_RGB888
    if(lcdltdc.dir)  //横屏
        return *(u32*)((u32)ltdc_framebuf[lcdltdc.activelayer]+lcdltdc.pixsize*(lcdltdc.pwidth*y+x));
    else             //竖屏
        return *(u32*)((u32)ltdc_framebuf[lcdltdc.activelayer]+lcdltdc.pixsize*(lcdltdc.pwidth*(lcdltdc.pheight-x-1)+y));
#else
    if(lcdltdc.dir)  //横屏
        return *(u16*)((u32)ltdc_framebuf[lcdltdc.activelayer]+lcdltdc.pixsize*(lcdltdc.pwidth*y+x));
    else             //竖屏
        return *(u16*)((u32)ltdc_framebuf[lcdltdc.activelayer]+lcdltdc.pixsize*(lcdltdc.pwidth*(lcdltdc.pheight-x-1)+y));
#endif 
}

/**
 * @brief LTDC填充矩形,使用DMA2D实现,(sx,sy),(ex,ey):填充矩形对角坐标,区域大小为:(ex-sx+1)*(ey-sy+1)
 *        注意: sx和ex <= lcddev.width-1 sy和ey <= lcddev.height-1
 * 
 * @param sx    起点水平坐标
 * @param sy    起点垂直坐标
 * @param ex    终点水平坐标
 * @param ey    终点垂直坐标
 * @param color 颜色值
 */
void ltdc_fill(u16 sx, u16 sy, u16 ex, u16 ey, u32 color)
{
    //以LCD面板为基准的坐标系,不随横竖屏变化而变化
    u32 psx;
    u32 psy;
    u32 pex;
    u32 pey;
    u32 timeout = 0;
    u32 addr;
    u16 offline;
    //坐标系转换
    if(lcdltdc.dir)  //横屏
    {
        psx = sx;
        psy = sy;
        pex = ex;
        pey = ey;
    }else            //竖屏
    {
        psx = sy;
        psy = lcdltdc.pheight-ex-1;
        pex = ey;
        pey = lcdltdc.pheight-sx-1;
    }
    offline = lcdltdc.pwidth-(pex-psx+1);
    addr    = ((u32)ltdc_framebuf[lcdltdc.activelayer]+lcdltdc.pixsize*(lcdltdc.pwidth*psy+psx));
    //使用DMA2D填充矩形
    RCC->AHB1ENR |= 1<<23;                          //使能DM2D时钟
    DMA2D->CR     = 3<<16;                          //寄存器到存储器模式
    DMA2D->OPFCCR = LCD_PIXFORMAT;                  //设置颜色格式
    DMA2D->OOR    = offline;                        //设置行偏移
    DMA2D->CR    &= ~(1<<0);                        //先停止DMA2D
    DMA2D->OMAR   = addr;                           //输出存储器地址
    DMA2D->NLR    = (pey-psy+1)|((pex-psx+1)<<16);  //设定行数寄存器
    DMA2D->OCOLR  = color;                          //设定输出颜色寄存器
    DMA2D->CR    |= 1<<0;                           //启动DMA2D
    while((DMA2D->ISR&(1<<1)) == 0)  //等待传输完成
    {
        timeout++;
        if(timeout > 0X1FFFFF)       //超时退出
            break;
    }  
    DMA2D->IFCR |= 1<<1;  //清除传输完成标志 	
}

/**
 * @brief 在指定区域内填充指定颜色块,DMA2D填充,此函数仅支持u16,RGB565格式的颜色数组填充
 *        (sx,sy),(ex,ey):填充矩形对角坐标,区域大小为:(ex-sx+1)*(ey-sy+1)
 *        注意: sx和ex <= lcddev.width-1 sy和ey <= lcddev.height-1
 * 
 * @param sx  起点水平坐标
 * @param sy  起点垂直坐标
 * @param ex  终点水平坐标
 * @param ey  终点垂直坐标
 * @param color 颜色值
 */
void ltdc_color_fill(u16 sx, u16 sy, u16 ex, u16 ey, u16 *color)
{
    //以LCD面板为基准的坐标系,不随横竖屏变化而变化
    u32 psx;
    u32 psy;
    u32 pex;
    u32 pey;
    u32 timeout = 0;
    u32 addr;
    u16 offline;
    //坐标系转换
    if(lcdltdc.dir)  //横屏
    {
        psx = sx;
        psy = sy;
        pex = ex;
        pey = ey;
    }else            //竖屏
    {
        psx = sy;
        psy = lcdltdc.pheight-ex-1;
        pex = ey;
        pey = lcdltdc.pheight-sx-1;
    }
    offline = lcdltdc.pwidth-(pex-psx+1);
    addr    = ((u32)ltdc_framebuf[lcdltdc.activelayer]+lcdltdc.pixsize*(lcdltdc.pwidth*psy+psx));
    //使用DMA2D填充矩形
    RCC->AHB1ENR  |= 1<<23;                          //使能DM2D时钟
    DMA2D->CR      = 0<<16;                          //存储器到存储器模式
    DMA2D->FGPFCCR = LCD_PIXFORMAT;                  //设置颜色格式
    DMA2D->FGOR    = 0;                              //前景层行偏移为0
    DMA2D->OOR     = offline;                        //设置行偏移
    DMA2D->CR     &= ~(1<<0);                        //先停止DMA2D
    DMA2D->FGMAR   = (u32)color;                     //源地址
    DMA2D->OMAR    = addr;                           //输出存储器地址
    DMA2D->NLR     = (pey-psy+1)|((pex-psx+1)<<16);  //设定行数寄存器
    DMA2D->CR     |= 1<<0;                           //启动DMA2D
    while((DMA2D->ISR&(1<<1)) == 0)  //等待传输完成
    {
        timeout++;
        if(timeout > 0X1FFFFF)       //超时退出
            break;
    }
    DMA2D->IFCR |= 1<<1;  //清除传输完成标志
} 

/**
 * @brief LCD清屏
 * 
 * @param color 颜色值
 */
void ltdc_clear(u32 color)
{
    ltdc_fill(0, 0, lcdltdc.width-1, lcdltdc.height-1, color);
}
